%! TEX root = ../main.tex
\documentclass[main]{subfiles}

\begin{document}

\chapter{プログラム構成}

\section{環境、使用言語}
本研究はvisual studio code(以下vscode)の拡張機能として実装する．
% この理由は（ここに理由を入力）だからである．
vscodeの拡張機能はtypescriptを用いて実装する．
環境としてJavaScript実行環境のNode.js，
及びjavascriptのAPIであるvscode APIを用いる．ディレクトリ構成を以下に示す．

\section{アルゴリズム}
本拡張機能の動作としては主に3つの段階に分けて考えることができる．
すなわち，現在のソースコードを抽象構文木化し，jsonファイルに変換して内容を取り込む入力部分，
抽象構文木化したソースコード群を比較評価し，現在のカーソル部分と類似した部分木を見つけ出す比較部分，
見つけた部分木から対応するヒントコードを表示する出力部分である.

\begin{description}
\item[1.入力部分 ] 　\\*
入力として学習者の現在編集しているコードファイル(以下元ファイルと称す)，及び元ファイル上でのカーソル現在位置，
すなわちコマンド呼び出し時にカーソルのあった行番号を取得する．
学習者は通常，現在編集しているコードの続きについてヒントを求めていると考えられるので
カーソル部分及びその前部分のコードをプログラム上で注目する．

コードの抽象構文木化にはC言語のコンパイラであるclangの機能を用いる．
clangにはコンパイルするソースファイルの抽象構文木を出力する機能があり，さらに結果をJSON形式で出力することもできる．
これを用い，コマンド呼び出し時に保存した学習者のソースファイルをclangを用いて抽象構文木化し
このJSONファイルを読み込んでプログラム上で扱う．
また，比較に用いる過去の回答コードもclangを用いて抽象構文木化しておく．こちらは今回手動で行った．
\item[2.比較部分 ] 　\\*
入力部分の項でも述べたように，まずは抽象構文木化した学習者のコードファイルを調査し
コマンド呼び出し時のカーソル部分のノードを検索する．
本研究ではコードのパターンマッチにおいて「注目箇所及び前後部分の兄弟ノードが一致する部分木を検索する」
ことによって類似コードを見つけ出すという手法をとる．そしてパターンがマッチした場合
そのマッチの具合に応じて点数をつけ，点数が一番高いものをヒントコードとして推薦する．
\item[3.出力部分 ] 　\\*
マッチしたコードの前後を取り出し，出力する．
\end{description}

ああああ
\end{document}